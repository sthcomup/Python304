### 缓存架构

[深入了解]: https://juejin.im/post/5b45cee0e51d45194b18cdbc#heading-41



### 缓存数据

- 数据类型
  - 数值
  - 数据库记录
  - 一个页面
- 数据的保存方式
  - 序列化字符串
    - 优点
      - 节省字符串存储空间
    - 缺点
      - 序列化有时间开销
      - 更新不方便
  - Redis其他数据类型hash\set\zset
    - 优点
      - 不需要序列化转换
      - 可以更新内部数据
    - 缺点
      - 比字符串存储空间占用大



### 缓存有效期与淘汰策略

##### 过期策略

- 定时过期：每个设置过期时间的key都有一个定时器，到过期时间自动清除，但是会占用大量CPU资源
- 惰性过期：只有当访问一个key时，才去判断该key是否过期，过期则清除，可以把最大化的节省CPU资源，但是会极大的占用内存空间
- 定期过期：每个一段时间，会扫描数据库expires字典中一定数量的key，判断其是否过期，过期则清除

##### 缓存淘汰

Redis的内存淘汰策略是指在Redis用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据

- LRU：最近最少使用，核心思想：**如果数据最近被访问过，那么将来被访问的几率也更高**
- LFU：最近最少使用算法，一个数据使用一次标记一下，根据标记值的大小进行排序



### [缓存模式](https://juejin.im/post/5af5b2c36fb9a07ac65318bd)

##### Cache Aside更新模式

- **失效**：先从cache中获取数据，没有，则从数据库中获取，成功后，将数据放入cache
- **命中**：从cache中获取数据，成功后返回
- **更新**：先把数据存储到数据库中，成功后，再让缓存失效

```
问题一：先更新数据库，后更新缓存。当两个并发的写操作处理数据会导致脏读，原因：先更新数据库的操作后更新缓存，后更新数据库的操作先更新缓存，导致数据不一致。
问题二：先删除缓存，后更新数据库。当两个并发的读写操作处理数据会导致脏读，原因：先执行的写操作将缓存删除，后执行的读操作从缓存中读取不到数据，又把数据库中旧的数据更新到了缓存中，然后写操作再更新数据库数据，导致数据不一致。
问题三：先更新数据库，再删除缓存。当两个并发的读写操作处理数据会导致脏读，原因：先执行的读操作从缓存中没有读取数据，接着去数据库中找到数据，这时写操作更新数据库，并删除了缓存，然后读操作才更新到缓存，导致数据不一致。但是这种情况出现的概率极低。
```

##### Read/Write Through 更新模式

- Read Through：在查询操作中更新缓存，由缓存服务自己来加载
- Write Through：在数据更新时，如果命中缓存，则更新缓存，然后由缓存服务来更新数据库

##### Write Behind Caching 

更新数据时，只更新缓存，不更新数据库，而缓存会异步的对数据库进行批量更新，性能提升很大



### 缓存问题

##### 缓存一致性

- 在上面

##### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透

- 解决方案
  - 空值缓存：在第一次查询不存在的数据后，将该Key与对应的空值存到缓存中，设置较短的有效时间，可以防止短时间内大量的该key攻击
  - bloom filter：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。

##### 缓存雪崩

如果所有的缓存失效时间相同，那么请求会同一时间发送到数据库中，数据库可能无法承受这么大的压力导致系统崩溃

- 解决方案
  - 线程互斥：每个时刻只有一个线程在执行请求，减轻数据库压力
  - 多级缓存：不同级别缓存设置的失效时间不同
  - 交错失效时间：给缓存加上一定区间的随机失效时间，不同的key设置不同的失效时间，避免同一时间失效







