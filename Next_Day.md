缓存

==scrapy -->  8/10==

Git SVA

Mysql和nosql的区别

##### 



##### queue

​	PriorityQueue（）--> !!!

​	Queue(FIFO)

​	LifoQueue()

### TCP 协议/UDP协议

#### TCP

+ TCP是面向连接的通讯协议，通过三次握手建立连接，通讯时完成四次挥手
+ 优点：
  + TCP在数据传输时，有确认，窗口，重传，阻塞等控制机制，能保证数据的正确性，较为可靠

- 缺点：
  - TCP相对于UDP速度慢一点，要求系统资源较

##### **三次握手四次挥手**

> 三次握手：是指在建立一个TCP连接时，需要客户端和服务端总共发送三个包
>
> >  1.第一次握手：客户端发送一个TCP的SYN标志位1的包指明客户端打算连接服务端，并发送初始序号X 
>
> > 2.第二次握手：服务器发回确认包（ACK）应答，即SYN和ACK标志位都为1时，将 确认序号设置为X+1 
>
> > 3.第三次握手：客户端再次发送确认包（ACK）SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确认字段中发送给服务端 

>四次挥手：TCP的连接拆除需要发送四个包，客户端和服务端均可主动发起挥手动作
>
>> 1.主动方发送Fin+Ack报文，并发送序号X，请求通信关闭
>
>> 2.被动方发送ACK报文，并置发送序号为Z，确认序号为X+1，答应你关闭通信
>
>>  3.被动方发送Fin+Ack报文，并置发送序号为Y，确认序号为X，也请求关闭通信
>
>> 4.主动方发送ack报文，并发送序号为X，确认序号为Y，也答应关闭通信

#### UDP

> UDP是面向无连接的通讯协议， 且不安全的协议，在通信过程中，它并不像TCP那样需要先建立一个连接，只要目的端口号和源端口号确定了， 就能直接发送信息报文，它只提供校验机制来保证报文的完整性，若校验失败，则直接丢报文，不做任何处理。 

+ 优点：
  + 传输速度快，操作简单，要求系统资源少，由于通讯不需要连接，可以实现广播发送
+ 缺点：
  + 由于UDP是无连接的，所有它并不知道接收端是否正确接收，也不重复发送，容易出现丢包现象,不可靠

##### 选择

TCP一般用于文件传输，邮件接发，远程登陆

UDP一般用于在线视频，网络电话





### [多进程]()。线程。协程

#### 进程

+ 进程 之间的通信由操作系统传递，导致通讯效率低，切换开销大
+ 密集CPU任务，需要充分利用多核CPU资源（大量并行计算）的时候
  - 缺陷：成本高，开销大

##### 进程之间的通信:

1. 管道：**` 速度慢，容量有限，只有父子进程能通讯`**
2. FIFO：**` 任何进程间都能通讯，但速度慢`**
3. 消息队列：**` 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完的数据的问题`**
4. 信号量：**` 不能传递复杂消息，只能用来同步`**
5. 共享内存区：**` 能够很容易控制容量，速度快，但要保持同步`**
   - 比如一个程序在写的时候，另一个程序要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间的通讯。不过没必要，线程间本来就已经共享了同一进程的一块内存

​	

#### 线程

- 线程分享进程的内存空间，通讯效率高，切换开销小。共享意味着竞争，导致数据不安全，可以引用“互斥锁”

- 而在cpython中，有GIL（全局解释器锁）：

  - 线程执行权限，进程中只有一个GIL

    - 好处：杜绝多个线程访问内存空间的安全问题

    - 坏处：不是真正的多线程，不能充分利用多核CPU的资源

  - 在I/O阻塞时，解释器会释放GIL

- 密集型I/O任务，使用多线程
  - 缺陷：同一时间切片只能运行一个线程，不能做到高并行，但可以做到==高并发==

#### 协程

- 在单线程上执行多个任务，用函数切换，开销极小。
  - genvent, monkey.patchall

- 多线程请求返回是无序的，而协程返回的数据是有序的
- 缺陷：单线程执行，处理密集CPU和本地磁盘I/O时，性能低。处理网络I/O性能高

### Docker

+ ###### 什么是Docker
  
  + 开源的应用容器引擎, 基于 [Go 语言](https://www.runoob.com/go/go-tutorial.html) 并遵从Apache2.0协议开源 
  + docker 重新定义了程序开发测试，交付和部署过程的开放平台。
  + docker可以保持开发，测试和生产环节高度一致
+ docker 利用了namespace 来做权限的控制和隔离， cgroups 进行资源的配置，通过 aufs 进一步提高文件系统的资源了利用率
+ 相对于VM，优势：
  + 启动速度快
  + 资源利用率高
  + 性能开销小



### Django 开发中对数据库的优化：

1. 设计表时，尽量少使用外键，影响插入和删除性能
2. 使用缓存， 减少数据库的访问
3. 在orm框架设计表时，能用varchar，就别用text
4. 给搜索高频的字段属性，在定义时创建索引
5. 在模块标签里使用with标签可以缓存Qset的查询结果

### Django 提升性能（高并发）

+ ##### 后端提升性能指标：
  
  + 并发数
+ 响应时间
  
+ #### web网站性能的优化：
  
  + web前端性能优化
    + 1.减少 http 请求，减少数据库的访问量，比如使用雪碧图。 
    + 2.使用浏览器缓存，将一些常用的 css，js，logo 图标，这些静态资源缓存到本地浏览器，通过设
      置 http 头中的 cache-control 和 expires 的属性，可设定浏览器缓存，缓存时间可以自定义。
    +  3 对 html，css，javascript 文件进行压缩，减少网络的通信量。
  + 应用服务器--
+ 储存服务器--
  
+ #### 解决 -优化

  + 合理应用缓存，对常用的动态数据，比如首页做缓存，或者其他常用的数据，并设置过期时间，减少数据库压力，提升网站性能
  + 使用celery消息队列，将耗时的操作放队列，让worker去监听队列任务，实现异步操作，如发邮件，发短信
  + nginx部署项目，提升效率，增加并发量
  + 搭建服务器集群，将并发访问请求分散到多台服务器上处理
  + 最后就是运维工作人员的性能优化技术了

### 高并发

+ ##### 什么是高并发

  +  通过设计保证系统能够同时并行处理很多请求 
    +  高并发相关常用的一些指标：
       +  响应时间（Response Time）
       +  吞吐量（Throughput）
       +  每秒查询率QPS（Query Per Second）
       +  并发用户数等 

+ ##### 如何提升系统的并发能力

  +  垂直扩展（Scale Up） 
    +  增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；
    +   提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；  
  +  水平扩展（Scale Out） 
    +  只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的 

+ ##### 解决方式：

  + HTML页面静态化

  + 2.图片服务器分离（我使用的是fastdfs轻量级的分布式文件存储系统）

  + 3.使用缓存（缓存存在于内存中读取快我的项目中使用redis作为缓存的数据库，redis是内存型数据作为存储缓存的数据库挺适合）

  + 4.数据库集群、库表散列

  + 5.使用负载均衡的方法（简单的配置可以用nginx来配置负载均衡，只需要设置 如下代码，即可实现简单的负载均衡

    ```
      upstream djangoserver {  
                  server      192.168.72.49:8080;  
                 server 	    192.168.72.49:8081;  
              } 
    ```

  + 6.镜像
  + 7.最新：CDN加速技术（此技术还在了解阶段，可自行去网上查找相关的资料）

### Mysql， MongoDB， Redis

#### MongoDB

+  MongoDB 以 BSON 结构（二进制）进行存储，对海量数据存储有着很明显的优势。 

+ 优点
  + 1.==性能优越:快速！==在适量级的内存的 MongoDB 的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快，
  + 2.==高扩展==:第三方支持丰富(这是与其他的 No SQL 相比，MongoDB 也具有的优势)
  + 3.自身的 ==Failover 机制==！
  +  4.==弱一致性==（最终一致），更能保证用户的访问速度 
  +  5.文档结构的存储方式，能够更便捷的获取数据: json 的存储格式
  + 6.==支持大容量的存储==,内置 GridFS 
  +  7.内置 Sharding 
+ 缺点：
  +   MongoDB 不支持事务操作(最主要的缺点)
  +   MongoDB 占用空间过大
      +  MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方

#### Redis

> 它就是一个不折不扣的内存数据库。

##### Redis 事务

> Redis的事务是一组命令的集合,一个事务的所有命令要么执行,要么都不执行

` multi:开启事务`

` exec:执行事务` 

redis不支持事务的回滚

##### Redis持久化存储

+ 持久化方式:

  > Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。 

- **RDB快照(默认)** 

  ```
  原理：
  	Redis借助了fork命令的copy on write机制。在生成快照试时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成RDB文件，使用redis的save命令调用这个过程
  级别：
  	save 900 1
  	save 300 10
  	save 60 10000
  优点：
  	1.RDB是保存某个时间点的数据集，适用于数据集的备份
  	2.RDB是一个单一文件，方便传输到远端数据中心，适用于灾难回复
  	3.RDB方式可以最大化redis的性能
  缺点：
  	一旦数据库出现问题，RDB文件中保存的数据并不是全新的额，从上次保存到Redis停机这段时间的数据全部丢失
  ```

- **AOF** 

  ```
  原理：
  	对每条写入命令作为日志，以aooend-only模式写入一个日志文件，在redis重启时，可以通过AOF写入的指令来重构整个数据集
  级别：
  	30s 写入一次
  	1s 写入一次
  	每次写操作就写入一次
  优点：
  	1.AOF可以更好的保护数据不丢失，一般每隔1秒执行一次fsync操作，如果redis挂掉，最多丢失1秒的数据
  	2.保存的AOF日志格式文件是按照redis协议的格式保存，易于读取
  缺点：
  	1.速度没有RDB快
  	2.在一个高并发的系统中，命令日志是一个非常庞大的数据，管理维护成本高，恢复重建时间会非常长
  	
  ```


- **` 选择` ** 

  RDB + AOF：综合使用两种持久化方式，用AOF保证数据不丢失，作为恢复数据的第一选择；用RDB来做冷备份，在AOF文件丢失或不可用的时候，用RDB进行快速的数据恢复

#### MySQL

##### MySQL的引擎

+  InnoDB和MyISAM是MySQL的存储引擎 
+  区别 

```tex
1.InnoDB支持事务,MyISAM不支持,对于InnoDB每一条SQL语言都默认封装成事务,自动提交,这样会影响速度,所以最好把多条SQL语言放在begin和commit之间,组成一个事务；
2.InnoDB支持外键,而MyISAM不支持.对一个包含外键的InnoDB表转为MYISAM会失败；
3.InnoDB是聚集索引,数据文件是和索引绑在一起的,必须要有主键,通过主键索引效率很高.但是辅助索引需要两次查询,先查询到主键,然后再通过主键查询到数据.因此,主键不应该过大,因为主键太大,其他索引也都会很大.而MyISAM是非聚集索引,数据文件是分离的,索引保存的是数据文件的指针.主键索引和辅助索引是独立的.
4.InnoDB不保存表的具体行数,执行select count(*) from table时需要全表扫描.而MyISAM用一个变量保存了整个表的行数,执行上述语句时只需要读出该变量即可,速度很快；
5.Innodb不支持全文索引,而MyISAM支持全文索引,查询效率上MyISAM要高；
6.MySQL5.6版本InnoDB已支持全文索引
```

- 选择

  ```tex
  1.是否要支持事务,如果要请选择innodb,如果不需要可以考虑MyISAM；
  2.如果表中绝大多数都只是读查询,可以考虑MyISAM,如果既有读写也挺频繁,请使用InnoDB.
  3.系统奔溃后,MyISAM恢复起来更困难,能否接受；
  4.MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM),说明其优势是有目共睹的,如果你不知道用什么,那就用InnoDB,至少不会差.
  ```

- 总结

  - 读操作多用MyISAM
  - 写操作多用InnoDB

##### 复制集和分布式

- 复制集：搭建主从数据库
  - 目的：
    - 数据库的数据相同，起到备份的作用
    - 高可用——HA ： 提高稳定性
    - 数据库的读写分离：**写操作涉及到锁的问题，不管是行锁还是表锁还是块锁，都是比较降低系统执行效率的事情。我们这样的分离是把写操作集中在一个节点上，而读操作其他的N个节点上进行，从另一个方面有效的提高了读的效率，保证了系统的高可用性**。
- 分布式：数据库的数据不同， 每部分的数据共同组成完整的数据集合
  - 每个节点被称为一个节点
  - 高吞吐（提高查询效率）
- 复制集和分布式可单独使用，也可组合使用，组合使用时，分布式的每个分片都是主，复制集的是从

##### MySQL主从复制原理

- master将改变记录到二进制日志（binary log)中，
- slave将master的binary log events拷贝到他的中继日志（relay log)
- SQL线程从中继日志中读取事件，更新slave的数据



##### MySQL数据库事务的特点

> 1. 原子性  2. 一致性  3. 隔离性   4. 持久性

- 事务隔离的四个级别

  - **Read Uncommitted:** ` 读取未提交, 隔离级别最低的一个事务级别.一个事务会读取到另一个事务更改后未提交的数据，当事务回滚后，这个事务读到的数据就是脏数据，称为脏读` 
  - **Read Committed**:`  读取已提交：该隔离级别下，一个事务会遇到不可重复读的问题。 `

  ```
  不可重复读：A事务内，需要多次读取同一个数据，同时，B事务修改了该数据，那么，A事务多次读取的数据可能不一致。虽然解决了脏读的问题，未提交之前数据不变，但是当A事务在不知道B事务的存在下，有可能两次读的数据不同，所以正确的就是只读一次，不要多次读取。
  ```

  - **Repeatable Read:** `  可重复读：该隔离级别下，不管是否提交，一个事务不会读到另一个事务的更改，每次都是读取的原始数。但是会出现幻读问题 ` 
  - **Serializable:** `  串行执行事务：最高级别的隔离，所有事务依次执行，避免了脏读和可重复读，但是降低了效率和程序性能 `

##### 读写分离对事务的影响

- 对于写操作，因为事务是单机的（不能跨服务器），所以开启事务和提交或回滚分散到不同服务器就会失效
- 对于包含读写操作时：与事务的隔离级别相关，可重复度有影响；其他没有影响。



##### 分布式ID--唯一的id

- Redis的inrc和inrcby
- 雪花算法



##### 索引的底层原理

- 建立底层平衡的搜索二叉树（B树）左儿子始终小于老子；右儿子始终大于老子。

- 索引提高了查询速度，但是会影响增删改的速度：

  ```
  当新增数据影响到二叉树的平衡时，二叉树需要重新调整结构，这个过程性能消耗大，所以速度慢
  ```

  



##### MySQL性能优化方法

- 按照三范式设计表
- 设计表时，考虑到有些字段为了方便查询，而采用空间换取时间的方法，适当增加冗余字段（反范式设计）
- 建立索引
- sql语句优化
  - 使用索引遵循最左原则
  - 不要 select * , 只查询要查询的字段
  - 尽量不使用联合查询
  - 普通查询 > 联合查询 > 子查询
  - SQL语句尽量大写
  - 选择恰当的数据类型，如整型的选择； VARCHAR
  - 对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎；
  - 对于模糊 like 查询 将导致全表扫描，应避免使用
- 内存型数据库：mysql + redis
- 配置主从，读写分离







#### MongoDB 和 Redis 的区别：

+ ######  简介

  + MongoDB 更类似 MySQL，支持字段索引、游标操作，其优势在于查询功能比较强大，擅长查询 JSON 数据，能存储海量数据，但是不支持事务。
  + MySQL 在大数据量时效率显著下降，MongoDB 更多时候作为关系数据库的一种替代。

+ ###### 集群

  + MongoDB 集群技术比较成熟，Redis从3.0开始支持集群。 

+ ###### 内存管理机制

  + Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。
  +  MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。


  + ###### 支持的数据结构

    + Redis 支持的数据结构丰富，包括hash、set、list等。
    +  MongoDB 数据结构比较单一（K-V），但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。


  + ###### 不适用的场景

    Ø  需要使用复杂sql的操作

     Ø  事务性系统 





### Nginx和uWSGI

+ nginx
  + 它是一个开源的高性能的HTTP服务器和反向代理
    1. 作为web服务器，他处理静态和索引文件的效果非常高
    2. 最大支持5W个并发连接，但占用很少的内存空间
    3. 稳定性高，配置简洁
       1. 强大的反向代理和负载均衡功能，平衡集群各个服务器负载压力的应用
  + uWSGI -- web服务器
    + 实现WSGI，uwsgi，http等协议
    + WSGI 是一种通信协议。
      + WSGI 是一种Web 服务器网关接口。
      + 它是一 个Web 服务器（如 nginx，uWSGI 等服务器）与 web 应用（如用 Flask 框架写的程序）通信的一种 规范。
    + uwsgi是一种线路协议而不是通信协议，在此常用于在 uWSGI 服务器与其他网络服务器的数据通信
    + uWSGI 是实现了 uwsgi 和WSGI 两种协议的Web 服务器。

### HTTP和HTTPS

+ ##### 主要区别：

  + HTTPS需要ca证书，需要一定的费用
  + HTTP是超文本传输协议，是无状态的；HTTPS是HTTP，SSL协议构建的可进行加密传输，身份认证的网络协议，比http更安全
  + 使用的端口不同，HTTP使用80，HTTPS使用443

+ ##### ***为什么大多数公司选择http而不选择https：***

  1. HTTPS在“握手阶段”比较耗时，而且连接缓存也不如HTTP高效，所以，HTTPS没HTTP速度快
  2. SSL证数（CA证书）是需要花钱的，并且需要每年投入，对很多小公司和个人开发者挡住了
  3. HTTPS对服务器资源占用率高， 也就是需要在硬件投入上花费更多。

### 面向过程和面向对象的区别

+  面向对象就是高度实物抽象化
+ 面向过程就是自顶向下的编程！ 

#### 面向过程:

+ 优点：
  + 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;
  + 比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 
+ 缺点：没有面向对象易维护、易复用、易扩展
  

#### 面向对象:

+ ##### 三特性

  + 继承
  + 多态
  + 封装

+ ##### 优点:

  +  易维护、易复用、易扩展，
  + 由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 

+ 缺点：

  + 性能比面向过程低 


### Socket

#### socket与TCP/IP的关系

- socket是应用层和传输层之间的一个抽象层
- 它把TCP/IP层的复杂操作抽象为几个简单的接口供应用层调用，从而实现进程在网络之间的通信

#### 什么是socket

-  Socket的英文原义是“插座” 。 通常也称作”套接字”，主要用于解决==网络进程间通信。==   

-  两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程。 

  

- 通信
  -  ==本地进程间通信== （PIPE、FIFO、message queue、semaphore、shared memary）可以通过进程ＩＤ唯一标识一个进程。 
  - ==网络进程通信：==` IP地址+协议+端口号 `唯一标识网络中的一个进程

#### socket（）函数

1. 创建套接字

   ```python
   socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   ```

2. bind()函数： 绑定端口
3. 



