### Python 高级

一.元类:

 	1. Python 中类方法,类实列方法,静态方法有何区别
     * 类方法: 是类对象的方法,在定义需要在上方使用"@classmethod" 进行装饰,形参为cls表示类对象,类对象和实列对象都可调用
     * 类实例方法：是类实例化对象的方法，只有实例对象可以调用，形参为 self，指代对象本身； 
     * 静态方法：是一个任意函数，在其上方使用“@staticmethod”进行装饰，可以用对象直接调用,静态方法实际上跟该类没有太大关系。 

二．内存管理与垃圾回收机制

​	1. Python 的内存管理机制及调优手段？

​			内存管理机制: 引用计数,垃圾回收,内存池

* 引用计数： 引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。	

* 垃圾回收 ：

  * 引用计数 

  引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某 

  个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如 

  某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0， 

  那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了

  * 标记清除 

  如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被 

  回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引 

  用摘掉，就会得出这两个对象的有效计数。
  *  分代回收 

    从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统 

    中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾 

    回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额 

    外操作。

三. 函数:

* 函数参数

  ​	python 的参数传递有: 位置参数,默认参数,可变参数,关键字参数

  * 不可变参数用值传递：

    像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象

  * 可变参数是引用传递的：

    比如像列表，字典这样的对象是通过引用传递、和 C 语言里面的用指针传递数组很相似，可变对象能在函数内部改变。 

* 对缺省参数理解:
  * 缺省参数指在调用函数的时候没有传入参数的情况下,调用默认参数,在调用函数的同时赋值时,所传入的参数会替代默认参数
    * *args 是不定长参数,他可以输入参数是不确定的,可以任意多个
    * **kwargs是关键参数,赋值的时候以 键 = 值的方式,参数可以任意多对在定义函数的时候不确定会有多少参数传入使,就可以使用两个参数
* 递归函数停止的条件:
  * 判断递归的次数是否达到某限定值
  * 判断运算的结果达到某个范围等,根据设计的目的来选
* Python 主要的内置数据类型都有哪些？
  * 布尔类型
  * 数字
  * 字符串
  * 列表
  * 元组
  * 字典
  * 集合

四.装饰器:

* 装饰器本质是一个python的函数,它可以让其他函数在不需要做任何代码情况下变动的前提下增加功能,装饰器的返回值也是一个函数对象

* 什么是闭包

  * 在函数内在定义一个函数,这个函数用到外边函数的变量,那么将这个函数以及用到的变量称之为闭包

*  生成器、迭代器的区别:

  * 生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且 

    生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当 

    发生器终结时,还会自动抛出 StopIteration 异常。

五. 面向对象:

* 类

* 对象

*  Python 中 is 和==的区别

  * is是判断a是否是b,通过id判断
  * ==是判断a对象的值是否是b对象的值,是通过value来判断

* Python 的魔法方法

  * 魔法方法就是可以给你的类增加魔力的特殊方法, 它们经常是 

    两个下划线包围来命名的（比如` __init__`，`__lt__`）

    * `__init__`构造器，当一个实例被创建的时候初始化的方法。但是它并 不是实例化调用的第一个方法。

    * `__new__`才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给` __init__`。 `__new__`很少使 

      用，但是也有它适合的场景，尤其 是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。

  * 将对象私有化，通过共有方法提供一个读取数据的接口。

    * if `__name__` == '`__main__`':

* 谈谈你对面向对象的理解

  * 面向对象是相对于面向过程而言的
  * 面向过程语言是基于数据分析,以及算法为中心的程序设计方法
  * 面向对象是一种基于结构分析,以数据为中心的程序设计思想,在面向对象有个很重要的东西就是叫类
    * 面向对象的三大特性: 封装,继承,多态

六.正则表达式:

* Python 里 match 与 search 的区别
  * match()函数会扫描re是不是在string的开始位置匹配
    * match()函数是从0位置开始匹配,匹配成功才返回,没有就返回None
  * search()函数会扫描整个string查找匹配

七.系统编程:

* 进程总结:
  * 程序运行在操作系统上的一个实列,就称之为进程,进程需要系统的资源:内存,时间,pid
  * 注意：进程间不共享全局变量。

* 谈谈你对多进程，多线程，以及协程的理解，项目是否用？
  * 进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。
  * 线程： 调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在一个进程至少有一个线程，叫主线程，而多个线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率。
  * 协程：是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和 栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切 换非常快

* 什么是多线程竞争

  * 线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即： 数据几乎同步会被多个线程占用，造成数据混乱 ，即所谓的线程不安全 

    * 怎么解决,用锁

      * 锁的好处:

        能确保某段关键代码只能一个线程从头到尾完整执行一遍能解决多线程资源竞争下的原子性

      * 坏处:

        阻止多线程的并发执行,还有致命问题:死锁

* 解释一下什么是锁，有哪几种锁?
  * 锁是python提供对线程控制的对象,有互斥锁,可重入锁

* 什么是死锁呢？

  * 就是若干子线程在系统资源竞争的时候,等待对方对某个资源解除单独占用的状态,结果谁都不愿意放开解除,互相干等,程序无法执行下去,这就是死锁

  * GIL 锁 全局解释器锁（只在 cpython 里才有）

    * 作用：限制多线程同时执行，保证同一时间只有一个线程执行，所以 cpython 里的多线程其实是伪多线程!

    * 所以 Python 里常常使用协程技术来代替多线程，协程是一种更轻量级的线程，进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块 gevent 下切换是遇到了 耗时操作才会切换。 

      三者的关系：进程里有线程，线程里有协程

* 说说下面几个概念：同步，异步，阻塞，非阻塞
  * 同步: 多个任务之间有先后顺序执行,一个执行完下个才能执行
  * 异步: 多个任务之间没有先后顺序执行,可以同时执行有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果,这叫回调
  * 阻塞: 如果卡住了调用者,调用者不能继续往下执行了,就是说调用者阻塞了
  * 非阻塞: 如果不会卡住,可以继续执行,就是说非阻塞.
  * 同步异步相对与多任务而言,阻塞非阻塞相当于代码而言
* Python 中的进程与线程的使用场景?
  * 多进程适合用在cpu 密集型操作(cpu 操作指令比较多，如位数多的浮点运算)
  * 多线程适合用在IO 密集型操作(读写数据操作较多的，比如爬虫)

* 线程是并发还是并行，进程是并发还是并行？
  * 线程是并发,进程是并行
  * 进程之间相互独立,是系统分配资源的最小单位,同一个线程中的所有线程共享资源

* 并行（parallel）和并发（concurrency）
  * 并行: 同一刻多个任务同时在运行
  * 并发: 在同一时间间隔内多个任务都在运行,但是并不会同一刻同时运行,存在互替执行情况
  * 实现并行的库有：multiprocessing 多进程
  * 实现并发的库有：threading 多线程

* IO 密集型和 CPU 密集型区别
  * IO 密集型：系统运作，大部分的状况是 CPU 在等 I/O (硬盘/内存)的读/写
  * CPU 密集型：大部份时间用来做计算、逻辑判断等 CPU 动作的程序称之 CPU 密集型