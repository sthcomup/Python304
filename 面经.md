# 面经

### MySQL

##### 复制集和分布式

- 复制集：搭建主从数据库
  - 目的：
    - 数据库的数据相同，起到备份的作用
    - 高可用——HA   ： 提高稳定性
    - 数据库的读写分离：**写操作涉及到锁的问题，不管是行锁还是表锁还是块锁，都是比较降低系统执行效率的事情。我们这样的分离是把写操作集中在一个节点上，而读操作其他的N个节点上进行，从另一个方面有效的提高了读的效率，保证了系统的高可用性**。
- 分布式：数据库的数据不同， 每部分的数据共同组成完整的数据集合
  - 每个节点被称为一个节点
  - 高吞吐（提高查询效率）

- 复制集和分布式可单独使用，也可组合使用，组合使用时，分布式的每个分片都是主，复制集的是从

##### MySQL主从复制原理

- master将改变记录到二进制日志（binary log)中，
- slave将master的binary log  events拷贝到他的中继日志（relay log)
- SQL线程从中继日志中读取事件，更新slave的数据

##### MySQL数据库事务的特点

```
1.原子性  2.一致性  3.隔离性  4.持久性
```

- 事务隔离的四种级别

  - **Read Uncommitted**:    `读取未提交，隔离级别最低的一种事务级别。一个事务会读取到另一个事务更改后未提交的数据，当事务回滚后，这个事务读到的数据就是脏数据，称为脏读`

  - **Read Committed**:    `读取已提交：该隔离级别下，一个事务会遇到不可重复读的问题。`

    ```
    不可重复读：A事务内，需要多次读取同一个数据，同时，B事务修改了该数据，那么，A事务多次读取的数据可能不一致。虽然解决了脏读的问题，未提交之前数据不变，但是当A事务在不知道B事务的存在下，有可能两次读的数据不同，所以正确的就是只读一次，不要多次读取。
    ```

  - **Repeatable Read**：`可重复读：该隔离级别下，不管是否提交，一个事务不会读到另一个事务的更改，每次都是读取的原始数。但是会出现幻读问题`

    ```
    幻读：一个事务查询数据，发现不存在，但是试图去更新这条不存在的数据时，可以更新成功，而且再次查询时可以读出数据。
    
    ```

    ![1568708996278](C:\Users\15797\AppData\Roaming\Typora\typora-user-images\1568708996278.png)

  - **Serializable**: `串行执行事务：最高级别的隔离，所有事务依次执行，避免了脏读和可重复读，但是降低了效率和程序性能`

##### 读写分离对事务的影响

  - 对于写操作，因为事务是单机的（不能跨服务器），所以开启事务和提交或回滚分散到不同服务器就会失效
  - 对于包含读写操作时：与事务的隔离级别相关，可重复度有影响；其他没有影响。

##### 分库分表

  - 当用户请求量过大时，需要进行分库分表
    - 垂直拆分：字段或表过多
    - 水平拆分： 数据量过大，将数据一分为多

##### 分布式ID--唯一的id

- Redis的inrc和inrcby
- 雪花算法

##### 索引的底层原理

- 建立底层平衡的搜索二叉树（B树）左儿子始终小于老子；右儿子始终大于老子。

- 索引提高了查询速度，但是会影响增删改的速度：

  ```
  当新增数据影响到二叉树的平衡时，二叉树需要重新调整结构，这个过程性能消耗大，所以速度慢
  ```

##### MySQL性能优化方法

- 按照三范式设计表
- 设计表时，考虑到有些字段为了方便查询，而采用空间换取时间的方法，适当增加冗余字段（反范式设计）
- 建立索引
- sql语句优化
  - 使用索引遵循最左原则
  - 不要 select * , 只查询要查询的字段
  - 尽量不使用联合查询
  - 普通查询 > 联合查询 > 子查询
  - SQL语句尽量大写
  - 选择恰当的数据类型，如整型的选择； VARCHAR 
  - 对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎；
  - 对于模糊 like 查询 将导致全表扫描，应避免使用
- 内存型数据库：mysql + redis
- 配置主从，读写分离

##### MySQL的引擎

InnoDB和MyISAM是MySQL的存储引擎

- 区别

  ```
  1.InnoDB支持事务,MyISAM不支持,对于InnoDB每一条SQL语言都默认封装成事务,自动提交,这样会影响速度,所以最好把多条SQL语言放在begin和commit之间,组成一个事务；
  2.InnoDB支持外键,而MyISAM不支持.对一个包含外键的InnoDB表转为MYISAM会失败；
  3.InnoDB是聚集索引,数据文件是和索引绑在一起的,必须要有主键,通过主键索引效率很高.但是辅助索引需要两次查询,先查询到主键,然后再通过主键查询到数据.因此,主键不应该过大,因为主键太大,其他索引也都会很大.而MyISAM是非聚集索引,数据文件是分离的,索引保存的是数据文件的指针.主键索引和辅助索引是独立的.
  4.InnoDB不保存表的具体行数,执行select count(*) from table时需要全表扫描.而MyISAM用一个变量保存了整个表的行数,执行上述语句时只需要读出该变量即可,速度很快；
  5.Innodb不支持全文索引,而MyISAM支持全文索引,查询效率上MyISAM要高；
  6.MySQL5.6版本InnoDB已支持全文索引
  ```

- 选择

  ```
  1.是否要支持事务,如果要请选择innodb,如果不需要可以考虑MyISAM；
  2.如果表中绝大多数都只是读查询,可以考虑MyISAM,如果既有读写也挺频繁,请使用InnoDB.
  3.系统奔溃后,MyISAM恢复起来更困难,能否接受；
  4.MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM),说明其优势是有目共睹的,如果你不知道用什么,那就用InnoDB,至少不会差.
  ```

- 总结

  - 读操作多用MyISAM
  - 写操作多用InnoDB



### Redis

##### Redis事务

Redis的事务是一组命令的集合，一个事务中的所有命令要么都执行，要么都不执行

`multi:开启事务`

`exec:执行事务`

Redis不支持事务的回滚

##### Redis持久化存储

- RDB 快照（默认）

  ```
  原理：
  	Redis借助了fork命令的copy on write机制。在生成快照试时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成RDB文件，使用redis的save命令调用这个过程
  级别：
  	save 900 1
  	save 300 10
  	save 60 10000
  优点：
  	1.RDB是保存某个时间点的数据集，适用于数据集的备份
  	2.RDB是一个单一文件，方便传输到远端数据中心，适用于灾难回复
  	3.RDB方式可以最大化redis的性能
  缺点：
  	一旦数据库出现问题，RDB文件中保存的数据并不是全新的额，从上次保存到Redis停机这段时间的数据全部丢失
  ```

- AOF

  ```
  原理：
  	对每条写入命令作为日志，以aooend-only模式写入一个日志文件，在redis重启时，可以通过AOF写入的指令来重构整个数据集
  级别：
  	30s 写入一次
  	1s 写入一次
  	每次写操作就写入一次
  优点：
  	1.AOF可以更好的保护数据不丢失，一般每隔1秒执行一次fsync操作，如果redis挂掉，最多丢失1秒的数据
  	2.保存的AOF日志格式文件是按照redis协议的格式保存，易于读取
  缺点：
  	1.速度没有RDB快
  	2.在一个高并发的系统中，命令日志是一个非常庞大的数据，管理维护成本高，恢复重建时间会非常长
  	
  ```

- 选择

  RDB + AOF：综合使用两种持久化方式，用AOF保证数据不丢失，作为恢复数据的第一选择；用RDB来做冷备份，在AOF文件丢失或不可用的时候，用RDB进行快速的数据恢复



### 多进程，多线程，协程

##### 多进程

一个运行的程序就是一个进程，一个没有运行的代码就是一个程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程之间数据不共享，开销大，而多进程就可以充分的利用多核cpu

##### 多线程

调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程最少有一个线程，叫主线程，多个线程之间共享内存，从而极大的提高了程序的运行效率，在cpython中，多线程是伪多线程，因为GIL锁的存在，限制的多线程的同时执行，所以多线程实际是并发执行的，即在同一时间间隔内多个任务都在执行，但是不会在同一时刻同时运行，村内在交替执行的情况

##### 协程

是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存 器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### TCP UDP HTTP

##### TCP

TCP是面向连接的通讯协议，通过三次握手建立连接，四次挥手完成通讯

```
三次握手：是指在建立一个TCP连接时，需要客户端和服务端总共发送三个包
	1.第一次握手：客户端发送一个TCP的SYN标志位1的包指明客户端打算连接服务端，并发送初始序号X
	2.第二次握手：服务器发回确认包（ACK）应答，即SYN和ACK标志位都为1时，将 确认序号设置为X+1
	3.第三次握手：客户端再次发送确认包（ACK）SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确认字段中发送给服务端
四次挥手：TCP的连接拆除需要发送四个包，客户端和服务端均可主动发起挥手动作
	1.主动方发送Fin+Ack报文，并发送序号X，请求通信关闭
	2.被动方发送ACK报文，并置发送序号为Z，确认序号为X+1，答应你关闭通信
	3.被动方发送Fin+Ack报文，并置发送序号为Y，确认序号为X，也请求关闭通信
	4.主动方发送ack报文，并发送序号为X，确认序号为Y，也答应关闭通信
```

```
优点： 
	TCP在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠
缺点：
	TCP相对UDP速度慢一点，要求系统资源较多
```

##### UDP

UDP是面向无连接，且不安全的协议，在通信过程中，它并不像TCP那样需要先建立一个连接，只要目的端口号和源端口号确定了， 就能直接发送信息报文，它只提供校验机制来保证报文的完整性，若校验失败，则直接丢报文，不做任何处理。

```
优点：
	UDP速度快，操作简单。要求系统资源较少，由于通讯不需要连接，可以实现广播发送
缺点：
	UDP传输数据前不创建连接，直接发送数据，接收端不确定一定能接收到完整数据，不可靠
```

##### 选择

TCP一般用于文件传输，邮件接发，远程登陆

UDP一般用于在线视频，网络电话

### MVC、MVT

##### MVC

- M：Model模型，和数据库进行交互

- V：View，视图，负责产生Html页面

- C：Controller，控制器，接收请求，进行处理，与M和V进行交互，返回响应

  ```
  
  ```

  

### Docker

简介：

​	Docker是一个开源的应用容器引擎，基于go语言。Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到流行的Linux机器中，也可以实现虚拟化。

​	容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低

优点：

```
1.简化程序：
	Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植	  的容器中，然后发布到流行的Linux机器中，也可以实现虚拟化。		Docker让开发者可以直接将自己的成果放入Docker中进行管理。方便快	 捷是Docker的最大优势。
2.避免选择恐惧症：
	Docker镜像中包含了运行环境和配置，所以Docker可以简化部署多种应	 用实例工作。比如web应用、后台应用、数据库应用等都可以打包成一个     镜像部署
3.节省开支：
	Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理	   的问题，也改变了虚拟化的方式。
```

应用场景：

```
1.web应用的自动化打包和发布
2.自动化测试和持续集成、发布
3.在服务型环境中部署和调整数据库或其他的后台应用
```

​	

### FastDFS

##### 简介

```
1.用C语言编写的一款开源的轻量级分布式文件系统
2.功能：文件存储、文件访问（上传、下载）、文件同步等，解决了大容器存储和负载均衡的问题。
3.为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标
4.可以用来搭建一套高性能的文件服务器集群，并提供文件上传、下载等该服务。
```

##### 架构

```
Client：
客户端，业务请求的发起方，通过专有接口，使用TCP/IP协议与Tracker或storage进行数据的交互，Fast DFS提供了upload、download、delete等接口供客户端使用
Tracker server：
跟踪服务器，主要做调度工作，起负载均衡的作用，在内村中记录集群中所有存储组和存储服务器的状态信息，时客户端和数据服务器交互的枢纽
Storage server：
存储服务器，文件和文件属性都保存到存储服务器上，Storage server直接利用os的文件系统调用管理文件
storage群中的横向可以扩容，纵向可以备份
```

##### 流程

```
上传：
1.storage定时向tracker上传状态信息
2.client向tracker上传连接请求
3.tracker查询可用storage
4.返回给client信息
5.client上传文件
6.storage生成file_id
7.storage将上传的内容写入到磁盘
8.返回给client file_id
9.client存储文件信息
```

```
下载：
1.storage定时向tracker上传状态信息
2.client向tracker下载连接请求
3.tracker查询可用storage
4.返回信息
5.client向storage发送file_id
6.storage查找文件
7.storage返回文件内容
```

##### 文件索引

是客户端上传文件后Storage返回给客户端的一个字符串，是以后访问该文件的索引信息

```
组名：文件上传过后所在的storage组名称
虚拟磁盘路径：storage配置的虚拟路径
数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件
文件名：由存储服务器根据特定信息生成
```

##### 优点

```
1.比各类云端存储会便宜一点
2.只能通过专用的API访问，处理效率高
3.支持纵向备份，横向扩容
4.相同文件在一个存储服务器中只会存储一份，节约磁盘空间
```

